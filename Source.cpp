#include <iostream>
#include <string>
#include <cstring>

using namespace std;

//4 lookup tables used for various functionalities in the encryption process

unsigned char s_box[256] = { //substitution box taken from Wikipedia

   0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
   0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
   0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
   0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
   0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
   0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
   0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
   0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
   0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
   0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
   0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
   0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
   0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
   0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
   0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
   0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};

unsigned char rcon[256] = { //rcon taken from Wikipedia
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
};

unsigned char mult2[] = { //used for mix column, taken from wikipedia
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};

unsigned char mult3[] = { //used for mix column, taken from wikipedia
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};

void printHex(unsigned char x) { //function for outputting the encrypted message in hexadecimal, C++'s built in doesn't add 0's & A's
	if (x / 16 < 10) cout << (char)((x / 16) + '0');
	if (x / 16 >= 10) cout << (char)((x / 16 - 10) + 'A');
	if (x % 16 < 10) cout << (char)((x % 16) + '0');
	if (x % 16 >= 10) cout << (char)((x % 16 - 10) + 'A');
}

void keyExpandCore(unsigned char* index, unsigned char c) {
	//steps of the key expand core: rotate, S-Box, Rcon

	//rotate left
	unsigned char t = index[0];
	index[0] = index[1];
	index[1] = index[2];
	index[2] = index[3];
	index[3] = t;

	//S-Box lookup, replace with the value at that part of the substitution box
	index[0] = s_box[index[0]];
	index[1] = s_box[index[1]];
	index[2] = s_box[index[2]];
	index[3] = s_box[index[3]];

	//Replace first part of the 4 byte & replace it with the rcon value at the iterator
	index[0] ^= rcon[c];
}

void keyExpand(unsigned char* inputKey, unsigned char* expandedKey) {

	//expanding 16 bytes into 176 bytes

	//1st 16 bytes of the original key:
	for (int c = 0; c < 16; c++) {
		expandedKey[c] = inputKey[c];
	}


	int byteGen = 16; //original key length is 16
	int rConItr = 1; //iterator for the rcon lookup table
	unsigned char temp[4]; //working in 4 byte increments so we only need 4 at a time

	while (byteGen < 176) { //while our key is not yet expanded to 176 byte

		for (int c = 0; c < 4; c++) { //for every 4 bytes
			temp[c] = expandedKey[c + byteGen - 4]; //read 4 bytes into temp array
		}

		if (byteGen % 16 == 0) { //every 4th run the key schedule and increment the rcon iterator
			keyExpandCore(temp, rConItr);
			rConItr++;
		}
		for (unsigned char d = 0; d < 4; d++) { //expanded key at the current place is now equal to the expanded key down 16 xor by the temp at the iterator
			expandedKey[byteGen] = expandedKey[byteGen - 16] ^ temp[d];
			byteGen++;
		}
	}
}

void subByte(unsigned char* state) {

	for (int c = 0; c < 16; c++) {
		state[c] = s_box[state[c]]; //whatever value of the item in state at that point gets replaced with that of the one is s_box
	}
}

void shiftRow(unsigned char* state) {

	unsigned char temp[16]; //temp array used to get values from state before applying them to state

	//these are the corresponding changes using the 4x4 matrix w/ 0 being 0,0 4 being 0,1, 8 being 0,2 and so on.

	temp[0] = state[0]; //first row no change
	temp[1] = state[5]; //shifted 1 to the left
	temp[2] = state[10]; //shifted by 2 to the left
	temp[3] = state[15]; //shifted by 3 to the left

	temp[4] = state[4]; //first row no change
	temp[5] = state[9]; //shifted 1 to the left
	temp[6] = state[14]; //shifted by 2 to the left
	temp[7] = state[3]; //shifted by 3 to the left

	temp[8] = state[8]; //first row no change
	temp[9] = state[13]; //shifted 1 to the left
	temp[10] = state[2]; //shifted by 2 to the left
	temp[11] = state[7]; //shifted by 3 to the left

	temp[12] = state[12]; //first row no change
	temp[13] = state[1]; //shifted 1 to the left
	temp[14] = state[6]; //shifted by 2 to the left
	temp[15] = state[11]; //shifted by 3 to the left

	for (int c = 0; c < 16; c++) { //applying the shifted values to be the current state of the encrypted message
		state[c] = temp[c];
	}

}

void mixColumn(unsigned char* state) {

	unsigned char temp[16]; //temp array used to get values from state before applying them to state

	//dot products, every 4th one will be sure moved 4 indices forward
	//use look up tables for multiplying by 2 & 3 bitwise

	temp[0] = (unsigned char)(mult2[state[0]] ^ mult3[state[1]] ^ state[2] ^ state[3]); //multiply by 2 by first of the 4th, xor add  the multiple of 3 by then next indice, then xor add the next 2 indices in state
	temp[1] = (unsigned char)(state[0] ^ mult2[state[1]] ^ mult3[state[2]] ^ state[3]); //xor add every beginning 4th xor add the  multiple of 2 of the next indice, xor added by the multiple of 3 of the next indice, and then xor added by the 4th indice
	temp[2] = (unsigned char)(state[0] ^ state[1] ^ mult2[state[2]] ^ mult3[state[3]]); //xor add first 2 idices xor added by third indice's multiple of 2 and finally xor added by fourth indice's multiple of 3
	temp[3] = (unsigned char)(mult3[state[0]] ^ state[1] ^ state[2] ^ mult2[state[3]]); //first state multipled by 3 xor added' by next 2 states and xor added by the multiple of the 4th indice by 3

	temp[4] = (unsigned char)(mult2[state[4]] ^ mult3[state[5]] ^ state[6] ^ state[7]); //multiply by 2 by first of the 4th, xor add  the multiple of 3 by then next indice, then xor add the next 2 indices in state
	temp[5] = (unsigned char)(state[4] ^ mult2[state[5]] ^ mult3[state[6]] ^ state[7]); //xor add every beginning 4th xor add the  multiple of 2 of the next indice, xor added by the multiple of 3 of the next indice, and then xor added by the 4th indice
	temp[6] = (unsigned char)(state[4] ^ state[5] ^ mult2[state[6]] ^ mult3[state[7]]); //xor add first 2 idices xor added by third indice's multiple of 2 and finally xor added by fourth indice's multiple of 3
	temp[7] = (unsigned char)(mult3[state[4]] ^ state[5] ^ state[6] ^ mult2[state[7]]); //first state multipled by 3 xor added' by next 2 states and xor added by the multiple of the 4th indice by 3

	temp[8] = (unsigned char)(mult2[state[8]] ^ mult3[state[9]] ^ state[10] ^ state[11]); //multiply by 2 by first of the 4th, xor add  the multiple of 3 by then next indice, then xor add the next 2 indices in state
	temp[9] = (unsigned char)(state[8] ^ mult2[state[9]] ^ mult3[state[10]] ^ state[11]); //xor add every beginning 4th xor add the  multiple of 2 of the next indice, xor added by the multiple of 3 of the next indice, and then xor added by the 4th indice
	temp[10] = (unsigned char)(state[8] ^ state[9] ^ mult2[state[10]] ^ mult3[state[11]]); //xor add first 2 idices xor added by third indice's multiple of 2 and finally xor added by fourth indice's multiple of 3
	temp[11] = (unsigned char)(mult3[state[8]] ^ state[9] ^ state[10] ^ mult2[state[11]]); //first state multipled by 3 xor added' by next 2 states and xor added by the multiple of the 4th indice by 3

	temp[12] = (unsigned char)(mult2[state[12]] ^ mult3[state[13]] ^ state[14] ^ state[15]); //multiply by 2 by first of the 4th, xor add  the multiple of 3 by then next indice, then xor add the next 2 indices in state
	temp[13] = (unsigned char)(state[12] ^ mult2[state[13]] ^ mult3[state[14]] ^ state[15]); //xor add every beginning 4th xor add the  multiple of 2 of the next indice, xor added by the multiple of 3 of the next indice, and then xor added by the 4th indice
	temp[14] = (unsigned char)(state[12] ^ state[13] ^ mult2[state[14]] ^ mult3[state[15]]); //xor add first 2 idices xor added by third indice's multiple of 2 and finally xor added by fourth indice's multiple of 3
	temp[15] = (unsigned char)(mult3[state[12]] ^ state[13] ^ state[14] ^ mult2[state[15]]); //first state multipled by 3 xor added' by next 2 states and xor added by the multiple of the 4th indice by 3


	for (int c = 0; c < 16; c++) { //applying the mixed column values to be the current state of the encrypted message
		state[c] = temp[c];
	}
}

void addRdKey(unsigned char* state, unsigned char* rdKey) {

	//takes in the current state of our message that's being encrypted and the roundkey
	for (int c = 0; c < 16; c++) { //the loop is getting every byte of the current state of the message
		state[c] ^= rdKey[c]; //^ is XOR
		//Adds the byte with the block of the round key using XOR
	}
}

void aesEncrypt(unsigned char* msg, unsigned char* key) {

	unsigned char state[16]; 
	//encrypt in blocks, copy the 16 byte message to the state
	for (int c = 0; c < 16; c++) {
		state[c] = msg[c];
	}

	int rdNum = 9; //setting number of rounds to 9 as the last round is different from the first 9 rounds

	unsigned char expandedKey[176]; //create variable for when our key is expanded

	keyExpand(key, expandedKey); //expands our key from main

	addRdKey(state, key); //initial round key addition

	for (int c = 0; c < rdNum; c++) { //first 9 rounds

		subByte(state); //byte subsitution
		shiftRow(state); //shifts bytes
		mixColumn(state); //mixes columns
		addRdKey(state, expandedKey + (16 * (c + 1))); //16 bytes of expanded key
	}

	//Final Rd get rid of mix columns
	subByte(state);
	shiftRow(state);
	addRdKey(state, expandedKey + 160); //last 16 bytes, 16 + 160 = 176

	for (int c = 0; c < 16; c++) { //copy over msg w/ encrypted msg
		msg[c] = state[c];
	}

}

void aesPreKeySet(unsigned char* msg) {
	//below is our key
	unsigned char key[16] = {
		54,	15,	78,	53,
		13,	92,	28,	9,
		38,	90,	26,	75,
		85,	90,	26,	79
	};
	// 36 0F 4E 35 0D 5C 1C 09 26 5A 1A 4B 55 5A 1A 4F key in hex

	aesEncrypt(msg, key); //sending the message and the key to be encrypted by AES

	cout << "Your encrypted message is:" << endl;

	for (int c = 0; c < 16; c++) { //print out the message
		printHex(msg[c]); //printing in hex
		cout << " ";
	}

}

int main() {

	bool choice; //bool for the 2 tests

	cout << "Select either 0 or 1 to encrypt the 16 byte/128-bit message: ";
	cin >> choice;

	if (choice == 0) {
		unsigned char msg[] = "Mukesh is great!"; //16 byte msg, 128-bit 
		cout << "You chose this message to be encrypted:\nMukesh is great!" << endl;
		aesPreKeySet(msg);
	}

	if (choice == 1) {
		unsigned char msg[] = "Tralfamadorian ."; //16 byte msg, 128-bit 
		cout << "You chose this message to be encrypted:\nTralfamadorian ." << endl;
		aesPreKeySet(msg);
	}

	return 0;
}